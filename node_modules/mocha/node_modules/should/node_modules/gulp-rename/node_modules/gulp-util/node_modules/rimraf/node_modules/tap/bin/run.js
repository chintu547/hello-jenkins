#!/usr/bin/env node
var node = process.execPath
var fs = require('fs')
var spawn = require('child_process').spawn
var fg = require('foreground-child')
var opener = require('opener')
var supportsColor = require('supports-color')
var nycBin = require.resolve('nyc/bin/nyc.js')
var glob = require('glob')
var isexe = require('isexe')

var coverageServiceTest = process.env.COVERAGE_SERVICE_TEST === 'true'

// console.error(process.argv.join(' '))
// console.error('CST=%j', process.env.COVERAGE_SERVICE_TEST)
// console.error('CRT=%j', process.env.COVERALLS_REPO_TOKEN)
// console.error('CCT=%j', process.env.CODECOV_TOKEN)
if (coverageServiceTest) {
  console.log('COVERAGE_SERVICE_TEST')
}

// Add new coverage services here.
// it'll check for the environ named and pipe appropriately.
var coverageServices = [
  {
    env: 'COVERALLS_REPO_TOKEN',
    bin: require.resolve('coveralls/bin/coveralls.js'),
    name: 'Coveralls'
  },
  {
    env: 'CODECOV_TOKEN',
    bin: require.resolve('codecov.io/bin/codecov.io.js'),
    name: 'Codecov'
  }
]

main()

function main () {
  var args = process.argv.slice(2)

  if (!args.length && process.stdin.isTTY) {
    console.error(usage())
    process.exit(1)
  }

  var options = parseArgs(args)

  if (!options) {
    return
  }

  process.stdout.on('error', function (er) {
    if (er.code === 'EPIPE') {
      process.exit()
    } else {
      throw er
    }
  })

  options.files = globFiles(options.files)

  if ((options.coverageReport || options.checkCoverage) &&
      options.files.length === 0) {
    runCoverageReport(options)
    return
  }

  if (options.files.length === 0) {
    console.error('Reading TAP data from stdin (use "-" argument to suppress)')
    options.files.push('-')
  }

  if (options.files.length === 1 && options.files[0] === '-') {
    if (options.coverage) {
      console.error('Coverage disabled because stdin cannot be instrumented')
    }
    stdinOnly(options)
    return
  }

  // By definition, the next block cannot be covered, because
  // they are only releva